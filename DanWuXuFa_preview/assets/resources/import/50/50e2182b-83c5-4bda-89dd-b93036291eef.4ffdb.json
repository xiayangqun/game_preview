[1,0,0,[["cc.TextAsset",["_name","text"],1]],[[0,0,1,3]],[[0,"playerBody-backup.effect","// Copyright (c) 2017-2019 Xiamen Yaji Software Co., Ltd.\n\nCCEffect %{\n  techniques:\n  - name: opaque\n    passes:\n    - vert: standard-vs:vert\n      frag: standard-fs:frag\n      properties: &props\n        tilingOffset:   { value: [1.0, 1.0, 0.0, 0.0] }\n        mainColor:      { value: [1.0, 1.0, 1.0, 1.0], target: albedo, editor: { displayName: Albedo, type: color } }\n        albedoScale:    { value: [1.0, 1.0, 1.0], target: albedoScaleAndCutoff.xyz }\n        alphaThreshold: { value: 0.5, target: albedoScaleAndCutoff.w, editor: { parent: USE_ALPHA_TEST } }\n        occlusion:      { value: 1.0, target: pbrParams.x }\n        roughness:      { value: 0.8, target: pbrParams.y }\n        metallic:       { value: 0.6, target: pbrParams.z }\n        normalStrenth:  { value: 1.0, target: pbrParams.w, editor: { parent: USE_NORMAL_MAP } }\n        emissive:       { value: [0.0, 0.0, 0.0, 1.0], editor: { type: color } }\n        emissiveScale:  { value: [1.0, 1.0, 1.0], target: emissiveScaleParam.xyz }\n        mainTexture:    { value: grey, target: albedoMap, editor: { displayName: AlbedoMap } }\n        normalMap:      { value: normal       }\n        pbrMap:         { value: grey         }\n        metallicRoughnessMap: { value: grey   }\n        occlusionMap:   { value: white        }\n        emissiveMap:    { value: grey         }\n        bodyColor:      { value: [1.0, 1.0, 1.0, 1.0],  editor: {type: color } }\n      migrations: &migs # existing material data migration\n        properties:\n          mainColor:      { formerlySerializedAs: albedo }\n          alphaThreshold: { formerlySerializedAs: albedoScale.w }\n          normalStrenth:  { formerlySerializedAs: pbrScale.w }\n          mainTexture:    { formerlySerializedAs: albedoMap }\n  - name: transparent\n    passes:\n    - vert: standard-vs:vert\n      frag: standard-fs:frag\n      depthStencilState:\n        depthTest: true\n        depthWrite: false\n      blendState:\n        targets:\n        - blend: true\n          blendSrc: src_alpha\n          blendDst: one_minus_src_alpha\n          blendDstAlpha: one_minus_src_alpha\n      properties: *props\n      migrations: *migs\n}%\n\nCCProgram shared-ubos %{\n  uniform Constants {\n    vec4 tilingOffset;\n    vec4 albedo;\n    vec4 albedoScaleAndCutoff;\n    vec4 pbrParams;\n    vec4 emissive;\n    vec4 emissiveScaleParam;\n    vec4 bodyColor;\n  };\n}%\n\nCCProgram standard-vs %{\n  precision highp float;\n  #include <builtin/uniforms/cc-global>\n  #include <legacy/decode-base>\n  #include <legacy/local-batch>\n  #include <legacy/input-standard>\n  #include <shared-ubos>\n\n  // #if USE_VERTEX_COLOR\n  //   in vec3 a_color;\n  //   out vec3 v_color;\n  // #endif\n\n  out vec3 v_position;\n  out vec3 v_normal;\n  #if USE_NORMAL_MAP\n    out vec3 v_tangent;\n    out vec3 v_bitangent;\n  #endif\n\n  \n  out vec2 v_uv;\n  in vec2 a_texCoord1;\n  out vec2 v_uv1;\n\n  vec4 vert () {\n    StandardVertInput In;\n    CCVertInput(In);\n\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n\n    vec4 pos = matWorld * In.position;\n\n    v_position = pos.xyz;\n    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n    #if USE_NORMAL_MAP\n      v_tangent = normalize((matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n      v_bitangent = cross(v_normal, v_tangent) * In.tangent.w; // note the cross order\n    #endif\n\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if HAS_SECOND_UV\n      v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #endif\n\n    // #if USE_VERTEX_COLOR\n    //   v_color = a_color;\n    // #endif\n\n    return cc_matProj * (cc_matView * matWorld) * In.position;\n  }\n}%\n\nCCProgram standard-fs %{\n  precision highp float;\n  #include <builtin/uniforms/cc-global>\n  #include <legacy/shading-standard>\n  #include <legacy/output-standard>\n  #include <common/color/gamma>\n  #include <shared-ubos>\n\n  in vec3 v_position;\n  in vec2 v_uv;\n  in vec2 v_uv1;\n  in vec3 v_normal;\n\n  // #if USE_VERTEX_COLOR\n  //   in vec3 v_color;\n  // #endif\n\n  #if USE_ALBEDO_MAP\n    uniform sampler2D albedoMap;\n    #pragma define-meta ALBEDO_UV options([v_uv, v_uv1])\n  #endif\n  #if USE_NORMAL_MAP\n    in vec3 v_tangent;\n    in vec3 v_bitangent;\n    uniform sampler2D normalMap;\n    #pragma define-meta NORMAL_UV options([v_uv, v_uv1])\n  #endif\n  #if USE_PBR_MAP\n    uniform sampler2D pbrMap;\n    #pragma define-meta PBR_UV options([v_uv, v_uv1])\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    uniform sampler2D metallicRoughnessMap;\n    #pragma define-meta METALLIC_ROUGHNESS_UV options([v_uv, v_uv1])\n  #endif\n  #if USE_OCCLUSION_MAP\n    uniform sampler2D occlusionMap;\n    #pragma define-meta OCCLUSION_UV options([v_uv, v_uv1])\n  #endif\n  #if USE_EMISSIVE_MAP\n    uniform sampler2D emissiveMap;\n    #pragma define-meta EMISSIVE_UV options([v_uv, v_uv1])\n  #endif\n\n  #pragma define-meta OCCLUSION_CHANNEL options([r, g, b])\n  #pragma define-meta ROUGHNESS_CHANNEL options([g, b, r])\n  #pragma define-meta METALLIC_CHANNEL  options([b, r, g])\n  #if USE_ALPHA_TEST\n    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r])\n  #endif\n\n  void surf (out StandardSurface s) {\n    vec4 baseColor = albedo;\n    // #if USE_VERTEX_COLOR\n    //   baseColor.rgb *= v_color;\n    // #endif\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture(albedoMap, ALBEDO_UV);\n      if(texColor.r == 1.0 && texColor.b == 1.0 && texColor.a == 1.0){\n        texColor = bodyColor;\n      }\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      baseColor *= texColor;\n    #endif\n    s.albedo = baseColor;\n    s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n\n    #if USE_ALPHA_TEST\n      if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n    #endif\n\n    s.normal = v_normal;\n    #if USE_NORMAL_MAP\n      vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n      s.normal =\n        (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n        (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n        nmmp.z * normalize(s.normal);\n    #endif\n\n    s.position = v_position;\n\n    vec4 pbr = pbrParams;\n    #if USE_PBR_MAP\n      vec4 res = texture(pbrMap, PBR_UV);\n      pbr.x *= res.OCCLUSION_CHANNEL;\n      pbr.y *= res.ROUGHNESS_CHANNEL;\n      pbr.z *= res.METALLIC_CHANNEL;\n    #endif\n    #if USE_METALLIC_ROUGHNESS_MAP\n      vec4 metallicRoughness = texture(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);\n      pbr.z *= metallicRoughness.METALLIC_CHANNEL;\n      pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;\n    #endif\n    #if USE_OCCLUSION_MAP\n      pbr.x *= texture(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n    #endif\n    s.occlusion = clamp(pbr.x, 0.0, 0.96);\n    s.roughness = clamp(pbr.y, 0.04, 1.0);\n    s.specularIntensity = 0.5;\n    s.metallic = pbr.z;\n\n    s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n    #if USE_EMISSIVE_MAP\n      s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n    #endif\n  }\n\n  vec4 frag () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShading(s);\n    return CCFragOutput(color);\n  }\n}%\n"]],0,0,[],[],[]]
